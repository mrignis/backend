"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintConfigCallback = exports.handleLint = void 0;
const openapi_core_1 = require("@redocly/openapi-core");
const config_1 = require("@redocly/openapi-core/lib/config");
const miscellaneous_1 = require("../utils/miscellaneous");
const colorette_1 = require("colorette");
const perf_hooks_1 = require("perf_hooks");
const getCommandNameFromArgs_1 = require("../utils/getCommandNameFromArgs");
function handleLint(argv, config, version) {
    return __awaiter(this, void 0, void 0, function* () {
        const apis = yield (0, miscellaneous_1.getFallbackApisOrExit)(argv.apis, config);
        if (!apis.length) {
            (0, miscellaneous_1.exitWithError)('No APIs were provided.');
        }
        if (argv['generate-ignore-file']) {
            config.styleguide.ignore = {}; // clear ignore
        }
        const totals = { errors: 0, warnings: 0, ignored: 0 };
        let totalIgnored = 0;
        // TODO: use shared externalRef resolver, blocked by preprocessors now as they can mutate documents
        for (const { path, alias } of apis) {
            try {
                const startedAt = perf_hooks_1.performance.now();
                const resolvedConfig = (0, openapi_core_1.getMergedConfig)(config, alias);
                const { styleguide } = resolvedConfig;
                (0, miscellaneous_1.checkIfRulesetExist)(styleguide.rules);
                styleguide.skipRules(argv['skip-rule']);
                styleguide.skipPreprocessors(argv['skip-preprocessor']);
                if (styleguide.recommendedFallback) {
                    process.stderr.write(`No configurations were provided -- using built in ${(0, colorette_1.blue)('recommended')} configuration by default.\n\n`);
                }
                process.stderr.write((0, colorette_1.gray)(`validating ${path.replace(process.cwd(), '')}...\n`));
                const results = yield (0, openapi_core_1.lint)({
                    ref: path,
                    config: resolvedConfig,
                });
                const fileTotals = (0, openapi_core_1.getTotals)(results);
                totals.errors += fileTotals.errors;
                totals.warnings += fileTotals.warnings;
                totals.ignored += fileTotals.ignored;
                if (argv['generate-ignore-file']) {
                    for (const m of results) {
                        config.styleguide.addIgnore(m);
                        totalIgnored++;
                    }
                }
                else {
                    (0, openapi_core_1.formatProblems)(results, {
                        format: argv.format,
                        maxProblems: argv['max-problems'],
                        totals: fileTotals,
                        version,
                    });
                }
                const elapsed = (0, miscellaneous_1.getExecutionTime)(startedAt);
                process.stderr.write((0, colorette_1.gray)(`${path.replace(process.cwd(), '')}: validated in ${elapsed}\n\n`));
            }
            catch (e) {
                (0, miscellaneous_1.handleError)(e, path);
            }
        }
        if (argv['generate-ignore-file']) {
            config.styleguide.saveIgnore();
            process.stderr.write(`Generated ignore file with ${totalIgnored} ${(0, miscellaneous_1.pluralize)('problem', totalIgnored)}.\n\n`);
        }
        else {
            (0, miscellaneous_1.printLintTotals)(totals, apis.length);
        }
        (0, miscellaneous_1.printUnusedWarnings)(config.styleguide);
        if (!(totals.errors === 0 || argv['generate-ignore-file'])) {
            throw new Error('Lint failed.');
        }
    });
}
exports.handleLint = handleLint;
function lintConfigCallback(argv, version) {
    if (argv['lint-config'] === 'off') {
        return;
    }
    if (argv.format === 'json') {
        // we can't print config lint results as it will break json output
        return;
    }
    return ({ document, resolvedRefMap, config }) => __awaiter(this, void 0, void 0, function* () {
        const problems = yield (0, openapi_core_1.lintConfig)({
            document,
            resolvedRefMap,
            config,
            severity: (argv['lint-config'] || 'warn'),
        });
        const fileTotals = (0, openapi_core_1.getTotals)(problems);
        (0, openapi_core_1.formatProblems)(problems, {
            format: argv.format,
            maxProblems: argv['max-problems'],
            totals: fileTotals,
            version,
        });
        const command = argv ? (0, getCommandNameFromArgs_1.getCommandNameFromArgs)(argv) : undefined;
        (0, miscellaneous_1.printConfigLintTotals)(fileTotals, command);
        if (fileTotals.errors > 0) {
            throw new config_1.ConfigValidationError();
        }
    });
}
exports.lintConfigCallback = lintConfigCallback;
