"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryUntilConditionMet = void 0;
const openapi_core_1 = require("@redocly/openapi-core");
/**
 * This function retries an operation until a condition is met or a timeout is exceeded.
 * If the condition is not met within the timeout, an error is thrown.
 * @operation The operation to retry.
 * @condition The condition to check after each operation result. Return false to continue retrying. Return true to stop retrying.
 *            If not provided, the first result will be returned.
 * @param onConditionNotMet Will be called with the last result right after checking condition and before timeout and retrying.
 * @param onRetry Will be called right before retrying operation with the last result before retrying.
 * @param startTime The start time of the operation. Default is the current time.
 * @param retryTimeoutMs The maximum time to retry the operation. Default is 10 minutes.
 * @param retryIntervalMs The interval between retries. Default is 5 seconds.
 */
function retryUntilConditionMet({ operation, condition, onConditionNotMet, onRetry, startTime = Date.now(), retryTimeoutMs = 600000, // 10 min
retryIntervalMs = 5000, // 5 sec
 }) {
    return __awaiter(this, void 0, void 0, function* () {
        function attempt() {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield operation();
                if (!condition) {
                    return result;
                }
                if (condition(result)) {
                    return result;
                }
                else if (Date.now() - startTime > retryTimeoutMs) {
                    throw new Error('Timeout exceeded');
                }
                else {
                    onConditionNotMet === null || onConditionNotMet === void 0 ? void 0 : onConditionNotMet(result);
                    yield (0, openapi_core_1.pause)(retryIntervalMs);
                    yield (onRetry === null || onRetry === void 0 ? void 0 : onRetry(result));
                    return attempt();
                }
            });
        }
        return attempt();
    });
}
exports.retryUntilConditionMet = retryUntilConditionMet;
