"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReuniteApiClient = void 0;
const fetch_with_timeout_1 = require("../../utils/fetch-with-timeout");
const node_fetch_1 = require("node-fetch");
const FormData = require("form-data");
const openapi_core_1 = require("@redocly/openapi-core");
class RemotesApiClient {
    constructor(domain, apiKey) {
        this.domain = domain;
        this.apiKey = apiKey;
    }
    getParsedResponse(response) {
        return __awaiter(this, void 0, void 0, function* () {
            const responseBody = yield response.json();
            if (response.ok) {
                return responseBody;
            }
            throw new Error(responseBody.title || response.statusText);
        });
    }
    getDefaultBranch(organizationId, projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/source`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            if (!response) {
                throw new Error(`Failed to get default branch.`);
            }
            try {
                const source = yield this.getParsedResponse(response);
                return source.branchName;
            }
            catch (err) {
                throw new Error(`Failed to fetch default branch: ${err.message || 'Unknown error'}`);
            }
        });
    }
    upsert(organizationId, projectId, remote) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/remotes`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
                body: JSON.stringify({
                    mountPath: remote.mountPath,
                    mountBranchName: remote.mountBranchName,
                    type: 'CICD',
                    autoMerge: true,
                }),
            });
            if (!response) {
                throw new Error(`Failed to upsert.`);
            }
            try {
                return yield this.getParsedResponse(response);
            }
            catch (err) {
                throw new Error(`Failed to upsert remote: ${err.message || 'Unknown error'}`);
            }
        });
    }
    push(organizationId, projectId, payload, files) {
        return __awaiter(this, void 0, void 0, function* () {
            const formData = new FormData();
            formData.append('remoteId', payload.remoteId);
            formData.append('commit[message]', payload.commit.message);
            formData.append('commit[author][name]', payload.commit.author.name);
            formData.append('commit[author][email]', payload.commit.author.email);
            formData.append('commit[branchName]', payload.commit.branchName);
            payload.commit.url && formData.append('commit[url]', payload.commit.url);
            payload.commit.namespace && formData.append('commit[namespaceId]', payload.commit.namespace);
            payload.commit.sha && formData.append('commit[sha]', payload.commit.sha);
            payload.commit.repository && formData.append('commit[repositoryId]', payload.commit.repository);
            payload.commit.createdAt && formData.append('commit[createdAt]', payload.commit.createdAt);
            for (const file of files) {
                formData.append(`files[${file.path}]`, file.stream);
            }
            payload.isMainBranch && formData.append('isMainBranch', 'true');
            const response = yield (0, node_fetch_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/pushes`, {
                method: 'POST',
                headers: {
                    Authorization: `Bearer ${this.apiKey}`,
                },
                body: formData,
                agent: (0, openapi_core_1.getProxyAgent)(),
            });
            try {
                return yield this.getParsedResponse(response);
            }
            catch (err) {
                throw new Error(`Failed to push: ${err.message || 'Unknown error'}`);
            }
        });
    }
    getRemotesList(organizationId, projectId, mountPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/remotes?filter=mountPath:/${mountPath}/`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            if (!response) {
                throw new Error(`Failed to get remotes list.`);
            }
            try {
                return yield this.getParsedResponse(response);
            }
            catch (err) {
                throw new Error(`Failed to get remote list: ${err.message || 'Unknown error'}`);
            }
        });
    }
    getPush({ organizationId, projectId, pushId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield (0, fetch_with_timeout_1.default)(`${this.domain}/api/orgs/${organizationId}/projects/${projectId}/pushes/${pushId}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${this.apiKey}`,
                },
            });
            if (!response) {
                throw new Error(`Failed to get push status.`);
            }
            try {
                return yield this.getParsedResponse(response);
            }
            catch (err) {
                throw new Error(`Failed to get push status: ${err.message || 'Unknown error'}`);
            }
        });
    }
}
class ReuniteApiClient {
    constructor(domain, apiKey) {
        this.domain = domain;
        this.apiKey = apiKey;
        this.remotes = new RemotesApiClient(this.domain, this.apiKey);
    }
}
exports.ReuniteApiClient = ReuniteApiClient;
